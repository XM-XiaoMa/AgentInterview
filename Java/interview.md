#### Java

1. java中==和equals和hashCode的区别

   ```markdown
   1、==：基本类型比较值，引用类型比较地址值
   2、equals：默认与==相似，String重写后判断对象内容
   3、hashcode：equals相等，hashcode相等；hashcode不相等，equal一定不相等
   ```

2. Java 基本类型占用字节和位数

   ```
   byte      ---  1byte   8bit
   short     ---  2byte   16bit
   int       ---  4byte   32bit
   long      ---  8byte   64bit
   char      ---  2byte   16bit
   float     ---  4byte   32bit
   double    ---  8byte   64bit
   boolean  
   ```

3. int 与 integer 区别

   ```
   1、integer是int的包装类，int是integer的基本类型
   1、integer需要实例化才能使用，默认值null; int不需实例化，默认值0
   ```

4. 谈谈对Java多态的了解

   ```
   1、多态就是同一操作（方法）作用于不同的对象时，可以有不同的解释，产生不同的执行结果。
   2、龙生九子，九龙子各有才华，这是多态赋予他们的拓展性，但是，他们终究还是龙，这是多态自身具有的统一性
   ```

5. String、StringBuffer、StringBuilder区别

   ```
   1、String值不可变，每次对String的操作都会生成新的String对象，涉及字符串经常修改时使用StringBuilder、StringBuffer
   2、StringBuilder不同于StringBuffer，非线程安全不可同步访问，相较于StringBuffer有速度优势
   ```

6. 什么是内部类？内部类的作用？

   ```
   将一个类定义在类中的任意位置上，例如类、方法、代码块中，这样的类称为内部类，内部类种类分为：
   1、成员内部类
   2、局部内部类
   3、静态内部类
   4、匿名内部类	
   ```

7. 匿名内部类访问局部变量时，局部变量为什么需要使用final修饰？

   ```
   1、数据一致性的说法：匿名内部类之所以可以访问局部变量，是因为在底层将这个局部变量的值传入到了匿名内部类中，并且以匿名内部类的成员变量的形式存在，这个值的传递过程是通过匿名内部类的构造器完成的。因为将数据拷贝完成后，如果不用final修饰，则原先的局部变量可以发生变化。如果局部变量发生变化后，匿名内部类是不知道的（因为他只是拷贝了局部变量的值，并不是直接使用的局部变量）。这里举个栗子：原先局部变量指向的是对象A，在创建匿名内部类后，匿名内部类中的成员变量也指向A对象。但过了一段时间局部变量的值指向另外一个B对象，但此时匿名内部类中还是指向原先的A对象。那么程序再接着运行下去，可能就会导致程序运行的结果与预期不同。成员变量就不同，成员变量是直接使用的，没有局部变量那样的通过构造函数赋值给内部类的成员变量之后再使用
   
   2、生命周期的说法:局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,局部变量如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用。
   ```

8. 抽象类和接口的区别

   ```
   |相同点：
   1、都不能被实例化。
   2、接口的实现类和抽象类的子类只有全部实现了接口或者抽象类中的方法后才可以被实例化。
   |不同点：
   1、接口只能定义抽象方法不能实现方法，抽象类既可以定义抽象方法，也可以实现方法。
   2、单继承，多实现。接口可以实现多个，只能继承一个抽象类。
   3、接口强调的是功能，抽象类强调的是所属关系。
   4、接口中的所有成员变量 为public static final， 静态不可修改，当然必须初始化。接口中的所有方法都是public abstract 公开抽象的。而且不能有构造方法。抽象类就比较自由了，和普通的类差不多，可以有抽象方法也可以没有，可以有正常的方法，也可以没有
   ```

9. 抽象类、接口的意义？

   ```
   1、抽象类抽象了子类通用特性，它是继承层级里子类的模板，子类可在抽象类基础上做各种拓展
   2、接口是各种抽象方法的集合，它严格规定了实现它的子类的各种行为规范
   ```

10. 面向对象原则有哪些？

    ```
    1、单一职责
    2、开放封闭：软件对拓展开放、对修改封闭
    3、依赖倒置
    4、接口隔离
    5、里氏替换	
    ```

11. 抽象类、接口的应用场景？

12. 工作中遇到的设计模式？

    ```
    ---常用的设计模式：
    
    单例模式：
    	模式：
    	1、饿汗式
    	2、懒汉式
    	3、静态内部类单例模式
    	注意事项：
    	1、使用懒汉式单例模式时注意线程问题
    	2、饿汗式、懒汉式单例模式构造器都是私有化的，不可继承
    	3、静态内部类实现单例模式，可集合懒汉式、饿汗式的的好处，线程安全且更少的代码实现延迟加载的目的
    	使用场景：
    	1、多线程的线程池设计，代用单例模式方便对线程池对池中的线程做控制
    	2、一般的经常使用的工具类
    	3、数据库连接池
    
    观察者模式：
    	注意事项：
    	1、针对观察者与被观察者分别定义接口，有利于分别进行功能拓展
    	2、观察者可自由添加、删除符合规则的观察者，通过通知方法通知各个观察者
    	3、观察者模式定义的 是一对多的依赖关系，通过接口对观察者与被观察者进行解耦
    	使用场景：	
    	1、打点，sdk接入多种打点方式，一对做各个节点的打点通知是最好的选择
    	2、数据更新时，各种捆绑的实例内资源的更新也可以使用这种模式
    
    工厂模式：
    	模式：
    	1、简单工厂模式：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类
    	2、工厂方法：简单工厂模式创建实例过程中可能会造成工厂类臃肿，每个对应的产品类都需要有个工厂类创建实例
    	3、抽象工厂：每个产品类都有自己的工厂类，用户就不能使用统一的方式对产品进行生产，这个时候可以再最外面抽象出一层工厂类去调用产品类的工厂类生产产品
    	注意事项：
    	1、抽象工厂与简单工厂模式区别在于，产品类生产过程中一系列繁琐的操作放在产品类中，简化用户直接使用的工厂类
    	2、工厂模式将对象的创建以及使用分离，隔离上层使用者对对象的创建
    	使用场景：
    	1、一个类型代表多个对象的时候，如车可直接代表宝马车、奔驰车
    	2、对象创建过程复杂时，需要对上层使用者隔离对对象的创建
    
    ```

13. 成员内部类为什么能访问外部类的属性？

    ```
    成员内部类中持有外部类的引用，这个引用时this。
    ```

14. java中的volatile?

    ```
    volatile是Java提供的一种轻量级的同步机制。Java语言包含两种内在同步机制：同步块、volatile变量。相比于synchronized，volatile更轻量级
    ```

15. 

16. 

17. 